<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canvas Swipe Cards (No React)</title>

  <!-- Bootstrap (CSS only) -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />

  <style>
    body { background: #f8f9fa; }
    .canvas-wrap {
      width: min(520px, 100%);
      aspect-ratio: 3 / 4;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none; /* critical: let us handle touch/pointer swipes */
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>

<body>
  <div class="container py-4">
    <div class="row justify-content-center">
      <div class="col-12 col-lg-6">
        <div class="fw-semibold mb-2">Canvas Swipe</div>

        <div class="canvas-wrap mb-3">
          <canvas id="swipeCanvas" aria-label="Swipe cards canvas"></canvas>
        </div>

        <div class="mt-3 p-3 bg-white rounded-3 shadow-sm">
          <div class="d-flex justify-content-between align-items-center">
            <div class="fw-semibold">Last action</div>
            <button id="btnReset" class="btn btn-sm btn-outline-primary">Reset deck</button>
          </div>
          <div id="log" class="mono mt-2 small text-secondary">—</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const rand = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  // German vocabulary (German shown first, English revealed on tap)
  const WORDS = [
    { de: "Apfel", en: "apple" },
    { de: "Buch", en: "book" },
    { de: "Fenster", en: "window" },
    { de: "Haus", en: "house" },
    { de: "Wasser", en: "water" },
    { de: "Freund", en: "friend" },
    { de: "Baum", en: "tree" },
    { de: "Stadt", en: "city" },
    { de: "Straße", en: "street" },
    { de: "Hund", en: "dog" },
    { de: "Katze", en: "cat" },
    { de: "Zeit", en: "time" },
    { de: "Welt", en: "world" },
    { de: "Schule", en: "school" },
    { de: "Arbeit", en: "work" },
    { de: "Frage", en: "question" },
    { de: "Antwort", en: "answer" },
    { de: "Reise", en: "journey" },
    { de: "Sonne", en: "sun" },
    { de: "Mond", en: "moon" },
    { de: "Meer", en: "sea" },
    { de: "Berg", en: "mountain" },
    { de: "Hand", en: "hand" },
    { de: "Herz", en: "heart" },
    { de: "Musik", en: "music" },
    { de: "Bild", en: "picture" },
    { de: "Sprache", en: "language" },
    { de: "Brot", en: "bread" },
    { de: "Milch", en: "milk" },
    { de: "Kaffee", en: "coffee" }
  ];

  function randomCard() {
    const chosen = WORDS[Math.floor(rand(0, WORDS.length))];
    return {
      german: chosen.de,
      english: chosen.en,
      revealed: false,
      shownAt: null,
      revealDurationMs: null
    };
  }

  // ---------- Canvas setup ----------
  const canvas = document.getElementById("swipeCanvas");
  const ctx = canvas.getContext("2d");

  // Make canvas crisp on HiDPI screens
  function resizeCanvasToDisplaySize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
  }

  // ---------- Deck / state ----------
  let deck = [];
  function buildDeck(count = 20) {
    deck = Array.from({ length: count }, () => randomCard());
    markTopCardShown();
  }

  const state = {
    // active card transform
    x: 0,
    y: 0,
    rot: 0,
    // drag/tap tracking
    dragging: false,
    startX: 0,
    startY: 0,
    pointerId: null,
    tapCandidate: false,
    // animation
    animating: false,
    // canvas logical size (in device px)
    W: 0,
    H: 0
  };

  // thresholds in *canvas device pixels*
  function swipeThreshold() {
    return state.W * 0.22; // ~22% width
  }

  // ---------- Drawing ----------
  function roundRectPath(x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function drawCard(card, tx, ty, rot, isTop) {
    const W = state.W;
    const H = state.H;

    // Card size
    const cw = W * 0.86;
    const ch = H * 0.82;
    const cx = (W - cw) / 2;
    const cy = (H - ch) / 2;

    ctx.save();
    // move to center, apply transform, then draw centered card
    ctx.translate(W / 2 + tx, H / 2 + ty);
    ctx.rotate(rot);
    ctx.translate(-W / 2, -H / 2);

    // shadow
    ctx.save();
    ctx.globalAlpha = isTop ? 0.20 : 0.10;
    ctx.fillStyle = "#000";
    roundRectPath(cx + 8, cy + 10, cw, ch, 22);
    ctx.fill();
    ctx.restore();

    // background
    ctx.fillStyle = "#ffffff";
    roundRectPath(cx, cy, cw, ch, 22);
    ctx.fill();

    // border
    ctx.strokeStyle = "rgba(0,0,0,0.08)";
    ctx.lineWidth = 2;
    roundRectPath(cx, cy, cw, ch, 22);
    ctx.stroke();

    // text
    ctx.fillStyle = "#111827";
    ctx.font = `${Math.round(W * 0.07)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(card.german, W / 2, H / 2 - H * 0.03);

    ctx.font = `${Math.round(W * 0.045)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillStyle = "#6b7280";
    if (card.revealed) {
      ctx.fillText(card.english, W / 2, H / 2 + H * 0.06);
    } else {
      ctx.fillText("Tap to reveal", W / 2, H / 2 + H * 0.06);
    }

    // swipe overlay (LIKE / NOPE)
    if (isTop) {
      const t = clamp(tx / swipeThreshold(), -1, 1);
      if (Math.abs(t) > 0.05) {
        ctx.save();
        const like = t > 0;
        const alpha = Math.min(1, Math.abs(t));
        ctx.globalAlpha = 0.9 * alpha;
        ctx.font = `${Math.round(W * 0.07)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.textAlign = "left";
        ctx.textBaseline = "top";

        const label = like ? "CORRECT" : "WRONG";
        ctx.fillStyle = like ? "rgba(25,135,84,0.90)" : "rgba(220,53,69,0.90)";
        ctx.strokeStyle = "rgba(255,255,255,0.90)";
        ctx.lineWidth = 6;

        const px = cx + cw * 0.08;
        const py = cy + ch * 0.10;

        // slight rotate for stamp
        ctx.translate(px, py);
        ctx.rotate(like ? -0.18 : 0.18);
        ctx.translate(-px, -py);

        ctx.strokeText(label, px, py);
        ctx.fillText(label, px, py);
        ctx.restore();
      }
    }

    ctx.restore();
  }

  function render() {
    resizeCanvasToDisplaySize();
    state.W = canvas.width;
    state.H = canvas.height;

    ctx.clearRect(0, 0, state.W, state.H);

    // Draw next card under the top card for depth
    const top = deck[0];
    const next = deck[1];

    if (!top) {
      // empty state
      ctx.fillStyle = "#6b7280";
      ctx.font = `${Math.round(state.W * 0.055)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("No more cards — reset deck", state.W / 2, state.H / 2);
      return;
    }

    if (next) {
      // subtle scale/offset based on drag progress
      const p = clamp(Math.abs(state.x) / swipeThreshold(), 0, 1);
      const underTx = 0;
      const underTy = lerp(14, 6, p);
      const underRot = 0;
      ctx.save();
      // fake "scale" by drawing smaller via translation? keep simple: tiny offset only
      ctx.restore();
      drawCard(next, underTx, underTy, underRot, false);
    }

    drawCard(top, state.x, state.y, state.rot, true);
  }

  // ---------- Interaction ----------
  function setTransformFromDrag(dx, dy) {
    state.x = dx;
    state.y = dy * 0.35; // damp vertical
    // rotate proportional to horizontal drag
    state.rot = (dx / state.W) * 0.35; // radians
  }

  function resetTransform() {
    state.x = 0;
    state.y = 0;
    state.rot = 0;
  }

  function logAction(text) {
    document.getElementById("log").textContent = text;
  }

  const history = [];

  function formatDuration(ms) {
    if (ms == null) return "—";
    const seconds = Math.max(0, ms) / 1000;
    return `${seconds.toFixed(2)}s`;
  }

  function markTopCardShown() {
    if (!deck[0]) return;
    if (deck[0].shownAt == null) {
      deck[0].shownAt = performance.now();
    }
  }

  function revealCard(card) {
    if (!card || card.revealed) return;
    card.revealed = true;
    card.revealDurationMs = performance.now() - card.shownAt;
    logAction(`REVEALED: ${card.german} → ${card.english} (${formatDuration(card.revealDurationMs)} to reveal)`);
  }

  function popCard(direction) {
    const card = deck.shift();
    if (!card) return;
    const correct = direction === "like";
    history.push({
      german: card.german,
      english: card.english,
      correct,
      revealDurationMs: card.revealDurationMs
    });
    logAction(`${correct ? "CORRECT" : "WRONG"}: ${card.german} → ${card.english} (revealed in ${formatDuration(card.revealDurationMs)})`);
    markTopCardShown();
  }

  function animateTo(targetX, targetY, targetRot, done) {
    state.animating = true;
    const start = { x: state.x, y: state.y, r: state.rot };
    const duration = 220;
    const t0 = performance.now();

    function step(t) {
      const p = clamp((t - t0) / duration, 0, 1);
      // easeOutCubic
      const e = 1 - Math.pow(1 - p, 3);

      state.x = lerp(start.x, targetX, e);
      state.y = lerp(start.y, targetY, e);
      state.rot = lerp(start.r, targetRot, e);
      render();

      if (p < 1) {
        requestAnimationFrame(step);
      } else {
        state.animating = false;
        done && done();
        render();
      }
    }
    requestAnimationFrame(step);
  }

  function completeSwipeIfNeeded() {
    const th = swipeThreshold();
    const dx = state.x;

    if (Math.abs(dx) >= th) {
      const dir = dx > 0 ? "like" : "nope";
      const offX = dx > 0 ? state.W * 1.2 : -state.W * 1.2;
      const offRot = dx > 0 ? 0.55 : -0.55;

      animateTo(offX, state.y, offRot, () => {
        popCard(dir);
        resetTransform();
      });
    } else {
      // spring back
      animateTo(0, 0, 0);
    }
  }

  // Pointer Events unify mouse + touch + pen
  canvas.addEventListener("pointerdown", (e) => {
    if (state.animating) return;
    if (!deck[0]) return;

    state.pointerId = e.pointerId;
    canvas.setPointerCapture(e.pointerId);
    state.startX = e.clientX;
    state.startY = e.clientY;
    state.tapCandidate = true;

    if (deck[0].revealed) {
      state.dragging = true;
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!state.dragging || state.animating) return;
    if (e.pointerId !== state.pointerId) return;

    const dx = (e.clientX - state.startX) * (window.devicePixelRatio || 1);
    const dy = (e.clientY - state.startY) * (window.devicePixelRatio || 1);
    setTransformFromDrag(dx, dy);
    render();
  });

  function endPointer(e) {
    if (e.pointerId !== state.pointerId) return;

    const dpr = window.devicePixelRatio || 1;
    const dx = (e.clientX - state.startX) * dpr;
    const dy = (e.clientY - state.startY) * dpr;
    const tapThreshold = 12 * dpr;

    if (!deck[0]?.revealed && state.tapCandidate && Math.hypot(dx, dy) <= tapThreshold) {
      revealCard(deck[0]);
      render();
    }

    if (state.dragging) {
      state.dragging = false;
      completeSwipeIfNeeded();
    }

    state.pointerId = null;
    state.tapCandidate = false;
  }

  canvas.addEventListener("pointerup", endPointer);
  canvas.addEventListener("pointercancel", endPointer);
  canvas.addEventListener("lostpointercapture", () => {
    if (state.dragging) {
      state.dragging = false;
      state.pointerId = null;
      state.tapCandidate = false;
      completeSwipeIfNeeded();
    }
  });

  function swipeDirection(direction) {
    if (state.animating || !deck[0] || !deck[0].revealed) return;
    const offX = direction === "like" ? state.W * 1.2 : -state.W * 1.2;
    const offRot = direction === "like" ? 0.55 : -0.55;
    animateTo(offX, 0, offRot, () => {
      popCard(direction);
      resetTransform();
    });
  }

  document.getElementById("btnReset").addEventListener("click", () => {
    buildDeck(20);
    resetTransform();
    logAction("—");
    render();
  });

  // Keyboard support (optional)
  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowRight") swipeDirection("like");
    if (e.key === "ArrowLeft") swipeDirection("nope");
  });

  // Init
  buildDeck(20);
  render();
  window.addEventListener("resize", render);
})();
</script>
</body>
</html>
