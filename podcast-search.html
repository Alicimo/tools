<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Podcast Episode Search</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap"
    rel="stylesheet"
  >
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  >
  <style>
    :root {
      color-scheme: light;
      --ink: #1c1f26;
      --muted: #5b6472;
      --surface: #ffffff;
      --surface-strong: #f7f4ef;
      --accent: #0f6ba8;
      --accent-strong: #0a4f7a;
      --accent-soft: #e4f0f7;
    }
    body {
      font-family: 'Manrope', 'Segoe UI', sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at top right, rgba(15, 107, 168, 0.16), transparent 40%),
        radial-gradient(circle at 20% 20%, rgba(255, 193, 7, 0.12), transparent 45%),
        #f2f4f8;
      min-height: 100vh;
    }
    .hero {
      background: linear-gradient(120deg, #0f6ba8 0%, #1c9bb3 50%, #3c8b74 100%);
      color: #fff;
    }
    .hero h1 {
      letter-spacing: -0.02em;
    }
    .hero p {
      color: rgba(255, 255, 255, 0.85);
    }
    .search-card {
      background: var(--surface);
      border: 1px solid rgba(15, 107, 168, 0.15);
      box-shadow: 0 1.5rem 3rem rgba(15, 107, 168, 0.08);
    }
    .form-control:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 0.25rem rgba(15, 107, 168, 0.2);
    }
    .result-card {
      border: 1px solid rgba(28, 31, 38, 0.08);
      background: var(--surface);
    }
    .result-meta {
      color: var(--muted);
      font-size: 0.9rem;
    }
    .snippet {
      color: #3b4452;
    }
    .audio-actions {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .audio-link {
      color: var(--accent-strong);
      text-decoration: none;
      font-weight: 600;
    }
    .audio-link:hover {
      text-decoration: underline;
    }
    @media (max-width: 768px) {
      .audio-actions {
        gap: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <header class="hero">
    <div class="container py-5">
      <div>
        <h1 class="display-6 fw-semibold mb-2">Podcast Episode Search</h1>
        <p class="mb-0">
          Search the complete Thomas and Friends Storytime archive by title and description.
        </p>
      </div>
    </div>
  </header>

  <main class="container py-5">
    <section class="search-card rounded-4 p-4 p-lg-5 mb-4">
      <label class="visually-hidden" for="searchInput">Search episodes</label>
      <div class="input-group input-group-lg">
        <span class="input-group-text">Search</span>
        <input
          id="searchInput"
          class="form-control"
          type="search"
          placeholder="Type a title, character, or story detail"
          autocomplete="off"
        >
      </div>
      <div class="d-flex flex-column flex-md-row align-items-md-center justify-content-between mt-3 gap-2">
        <div id="status" class="result-meta">Loading episodes…</div>
        <div id="meta" class="result-meta"></div>
      </div>
    </section>

    <section id="results" class="d-flex flex-column gap-3" aria-live="polite"></section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
  <script>
    const state = {
      episodes: [],
      fuse: null,
      query: ''
    }

    const searchInput = document.getElementById('searchInput')
    const resultsEl = document.getElementById('results')
    const statusEl = document.getElementById('status')
    const metaEl = document.getElementById('meta')
    const MAX_SNIPPET = 240

    const setStatus = (message) => {
      statusEl.textContent = message
    }

    const formatDate = (value) => {
      if (!value) return 'Unknown date'
      const date = new Date(value)
      if (Number.isNaN(date.getTime())) return 'Unknown date'
      return date.toLocaleDateString(undefined, {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      })
    }

    const truncate = (text, max) => {
      if (text.length <= max) return text
      return `${text.slice(0, max)}…`
    }

    const buildSnippet = (text, query) => {
      const cleanText = text || ''
      if (!cleanText) return 'No description available.'
      if (!query) return truncate(cleanText, MAX_SNIPPET)
      const lowerText = cleanText.toLowerCase()
      const lowerQuery = query.toLowerCase()
      const index = lowerText.indexOf(lowerQuery)
      if (index === -1) {
        return truncate(cleanText, MAX_SNIPPET)
      }
      const start = Math.max(0, index - 90)
      const end = Math.min(cleanText.length, index + lowerQuery.length + 140)
      const prefix = start > 0 ? '…' : ''
      const suffix = end < cleanText.length ? '…' : ''
      return prefix + cleanText.slice(start, end) + suffix
    }

    const parseDateValue = (value) => {
      if (!value) return 0
      const date = new Date(value)
      if (Number.isNaN(date.getTime())) return 0
      return date.getTime()
    }

    const formatDuration = (value) => {
      if (value === null || value === undefined) return ''
      const total = Number(value)
      if (!Number.isFinite(total) || total <= 0) return ''
      const hours = Math.floor(total / 3600)
      const minutes = Math.floor((total % 3600) / 60)
      const seconds = Math.floor(total % 60)
      if (hours > 0) {
        return `${hours}h ${minutes.toString().padStart(2, '0')}m`
      }
      return `${minutes}m ${seconds.toString().padStart(2, '0')}s`
    }

    const renderResults = (items, query) => {
      resultsEl.replaceChildren()
      if (!items.length) {
        const emptyCard = document.createElement('div')
        emptyCard.className = 'card result-card p-4'
        const emptyTitle = document.createElement('h2')
        emptyTitle.className = 'h5 mb-2'
        emptyTitle.textContent = query ? 'No matches found' : 'Type to search'
        const emptyText = document.createElement('p')
        emptyText.className = 'snippet mb-0'
        emptyText.textContent = query
          ? 'Try another keyword or a character name from the story.'
          : 'Start typing to search episode titles and descriptions.'
        emptyCard.appendChild(emptyTitle)
        emptyCard.appendChild(emptyText)
        resultsEl.appendChild(emptyCard)
        metaEl.textContent = ''
        return
      }

      items.forEach((item) => {
        const card = document.createElement('article')
        card.className = 'card result-card p-4'

        const title = document.createElement('h2')
        title.className = 'h5 mb-2'
        title.textContent = item.title || 'Untitled episode'

        const meta = document.createElement('div')
        meta.className = 'result-meta mb-3'
        const duration = formatDuration(item.duration)
        meta.textContent = duration
          ? `${formatDate(item.published)} · ${duration}`
          : formatDate(item.published)

        const snippet = document.createElement('p')
        snippet.className = 'snippet mb-3'
        snippet.textContent = buildSnippet(item.description, query)

        const audioWrap = document.createElement('div')
        audioWrap.className = 'audio-actions'

        if (item.audio_url) {
          const audio = document.createElement('audio')
          audio.setAttribute('controls', '')
          audio.setAttribute('preload', 'none')
          audio.src = item.audio_url
          audioWrap.appendChild(audio)

          const audioLink = document.createElement('a')
          audioLink.className = 'audio-link'
          audioLink.href = item.audio_url
          audioLink.target = '_blank'
          audioLink.rel = 'noopener noreferrer'
          audioLink.textContent = 'Open audio in new tab'
          audioWrap.appendChild(audioLink)
        } else {
          const noAudio = document.createElement('div')
          noAudio.className = 'result-meta'
          noAudio.textContent = 'Audio link not available for this episode.'
          audioWrap.appendChild(noAudio)
        }

        card.appendChild(title)
        card.appendChild(meta)
        card.appendChild(snippet)
        card.appendChild(audioWrap)
        resultsEl.appendChild(card)
      })

      metaEl.textContent = `${items.length} result${items.length === 1 ? '' : 's'}`
    }

    const buildFuse = (episodes) => {
      return new Fuse(episodes, {
        includeScore: true,
        minMatchCharLength: 2,
        threshold: 0.35,
        keys: [
          { name: 'title', weight: 0.7 },
          { name: 'description', weight: 0.3 }
        ]
      })
    }

    const runSearch = (query) => {
      state.query = query
      const trimmed = query.trim()
      if (!trimmed) {
        renderResults([], '')
        setStatus('Ready to search the archive.')
        return
      }

      if (!state.fuse) {
        renderResults([], trimmed)
        setStatus('Search is not ready yet.')
        return
      }

      const results = state.fuse.search(trimmed)
      const mapped = results.map((entry) => ({
        item: entry.item,
        score: entry.score ?? 1
      }))

      mapped.sort((a, b) => {
        const scoreDiff = a.score - b.score
        if (Math.abs(scoreDiff) > 0.05) return scoreDiff
        return parseDateValue(b.item.published) - parseDateValue(a.item.published)
      })

      renderResults(mapped.map((entry) => entry.item), trimmed)
      setStatus(`Showing matches for "${trimmed}".`)
    }

    let debounceTimer
    const handleInput = (event) => {
      const value = event.target.value
      window.clearTimeout(debounceTimer)
      debounceTimer = window.setTimeout(() => runSearch(value), 200)
    }

    const loadEpisodes = async () => {
      try {
        const response = await fetch('resources/episodes.json', { cache: 'no-store' })
        if (!response.ok) {
          throw new Error(`Failed to load episodes.json (${response.status})`)
        }
        const data = await response.json()
        state.episodes = Array.isArray(data.episodes) ? data.episodes : []
        state.fuse = buildFuse(state.episodes)
        setStatus(`Loaded ${state.episodes.length} episodes.`)
        renderResults([], '')
      } catch (error) {
        console.error(error)
        setStatus('Unable to load the local episode dataset.')
        renderResults([], '')
      }
    }

    searchInput.addEventListener('input', handleInput)
    loadEpisodes()
  </script>
</body>
</html>
